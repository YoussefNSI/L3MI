%skeleton "lalr1.cc"
%require "3.0"

%defines
%define api.parser.class { Parser }
%define api.value.type variant
%define parse.assert

%locations

%code requires{
    #include "contexte.hh"
    #include "expressionBinaire.hh"
    #include "expressionUnaire.hh"
    #include "constante.hh"
    #include "variable.hh"
    #include "bloc.h"

    class Scanner;
    class Driver;
    class Bloc;

    struct TitreInfo{
        std::string texte;
        int niveau;
    }; 

}

%parse-param { Scanner &scanner }
%parse-param { Driver &driver }

%code{
    #include <iostream>
    #include <string>
    #include <memory>
    #include <map>
    
    #include "scanner.hh"
    #include "driver.hh"
    #include "bloc.h"


    std::unique_ptr<Document> doc = std::make_unique<Document>();


    #undef  yylex
    #define yylex scanner.yylex
}

%token                 NEWLINE
%token <TitreInfo>     TITRE SOUS_TITRE
%token <std::string>   PARAGRAPHE IMAGE
%token <std::string>   DEFINE TITREPAGE STYLE
%token <std::string>   ATTRIBUT PROPRIETE
%token <std::string>   SI SINON FINSI POUR FINI IDENTIFIANT
%token <int>           ENTIER
%token <std::string>   CHAINE
%token <std::string>   HEX_COULEUR RGB_COULEUR
%token <std::string>   EGAL CROCHET_FERMANT CROCHET_OUVRANT DEUX_POINTS VIRGULE POINT_VIRGULE
%token <std::string>   PARENTHESE_OUVRANTE PARENTHESE_FERMANTE ACCOLADE_OUVRANTE ACCOLADE_FERMANTE


%type <std::unique_ptr<Titre>> titre sous_titre
%type <std::unique_ptr<Bloc>> paragraphe element
%type std::map<std::string, std::map<std::string, std::string>> attributs
%type std::map<std::string, std::string> liste_attributs
%type <std::string> valeur

%%

programme:
    elements
;

elements:
    element elements
    |
;

element:
    titre
    | sous_titre
    | paragraphe
    | image
    | define
    | style
    | titrepage
    | variable
;

titre:
    TITRE attributs CHAINE { 
        $$ = std::make_unique<Titre>($2, $3.texte, 1);
        doc->addBloc(std::move($$));
    }
    | TITRE CHAINE { 
        $$ = std::make_unique<Titre>(std::map<std::string, std::string>(), $2.texte, 1);
        doc->addBloc(std::move($$));
    }
;

sous_titre:
    SOUS_TITRE attributs CHAINE { 
        $$ = std::make_unique<Titre>($2, $3.texte, $3.niveau);
        doc->addBloc(std::move($$));
    }
    | SOUS_TITRE CHAINE { 
        $$ = std::make_unique<Titre>(std::map<std::string, std::string>(), $2.texte, $2.niveau);
        doc->addBloc(std::move($$));
    }
;

paragraphe:
    PARAGRAPHE attributs CHAINE { 
        $$ = std::make_unique<Paragraphe>($2, $3);
        doc->addBloc(std::move($$));
    }
    | PARAGRAPHE CHAINE { 
        $$ = std::make_unique<Paragraphe>(std::map<std::string, std::string>(), $2);
        doc->addBloc(std::move($$));
    }
;

image:
    IMAGE CHAINE { 
        $$ = std::make_unique<Image>($2);
        doc->addBloc(std::move($$));
    }
;

attributs:
    CROCHET_OUVRANT liste_attributs CROCHET_FERMANT { 
        $$ = $2;
    }
;

liste_attributs:
    attribut {
        $$ = $1;
    }
    | attribut VIRGULE liste_attributs {
        $$ = $1;
        $$.insert($3.begin(), $3.end());
    }
    | attribut NEWLINE liste_attributs {
        $$ = $1;
        $$.insert($3.begin(), $3.end());
    }
    |
;

attribut:
    nomattribut DEUX_POINTS valeur { 
         $$ = std::map<std::string, std::string>{{ $1, $3 }};
    }
;

nomattribut:
    largeur
    | hauteur
    | couleurTexte
    | couleurFond
    | opacite
;

largeur:
    ATTRIBUT { $$ = "width"; }
    ;

hauteur:
    ATTRIBUT { $$ = "height"; }
    ;

couleurTexte:
    ATTRIBUT { $$ = "color"; }
    ;

couleurFond:
    ATTRIBUT { $$ = "background-color"; }
    ;

opacite:
    ATTRIBUT { $$ = "opacity"; }
    ;

valeur:
    ENTIER
    | HEX_COULEUR
    | RGB_COULEUR
    | CHAINE
    ;

define:
    DEFINE PARENTHESE_OUVRANTE PROPRIETE PARENTHESE_FERMANTE ACCOLADE_OUVRANTE valeur ACCOLADE_FERMANTE 
    { 
        doc->setPropriete($3, $6);
    }
    ;

titrepage:
    TITREPAGE CHAINE { 
        $$ = std::make_unique<TitrePage>($2);
        doc->addBloc(std::move($$));
    }
;

variable:
    IDENTIFIANT EGAL valeurvar { 
        driver.storeVariable($1, std::move($3));
    }
;

valeurvar:
    ENTIER
    | HEX_COULEUR
    | RGB_COULEUR
    | element
;

style:
    STYLE PARENTHESE_OUVRANTE IDENTIFIANT PARENTHESE_FERMANTE ACCOLADE_OUVRANTE attributs ACCOLADE_FERMANTE 
    { 
        doc->setStyle($3, $6);
    }
;
    
%%

void yy::Parser::error( const location_type &l, const std::string & err_msg) {
    std::cerr << "Erreur : " << l << ", " << err_msg << std::endl;
}
